//Synchronous programming
const name = "Mirim";
constant greeting = 'Hello, my name is ${name}!';
console.log(greeting);

/* In this code:

1. Declares a string called name.
2. Declares another string called greeting, which uses name.
3. Outputs the greeting to the JavaScript console


*/

/* continue

We should note here that the browser effectively steps
through the program one line at a time, in order we wrote it
At each point, the browser waits for the line to finish its work
before going on the next line.
It has to do this because each line depends on the work in the 
preceding lines

That make this a synchronous program.
It would still be synchronous even if we called a
separate  function like this 
*/

function makeGreeting(name){
    return 'Hello, my name is ${name}!';
}

const name = "Mirim";
const greeting = makingGreeting(name);
console.log(greeting);
//"Hello, my name is Miriam!"


/*

Here, makeGreeting() is a synchronous function because
the caller has to wait for the function to finish its work
and return a value before the caller can continue

*/


// A long-running synchronous function

const MAX_PRIME = 1000000;

function isPrime(n) {
  for (let i = 2; i <= Math.sqrt(n); i++) {
    if (n % i === 0) {
      return false;
    }
  }
  return n > 1;
}

const random = (max) => Math.floor(Math.random() * max);

function generatePrimes(quota) {
  const primes = [];
  while (primes.length < quota) {
    const candidate = random(MAX_PRIME);
    if (isPrime(candidate)) {
      primes.push(candidate);
    }
  }
  return primes;
}

const quota = document.querySelector("#quota");
const output = document.querySelector("#output");

document.querySelector("#generate").addEventListener("click", () => {
  const primes = generatePrimes(quota.value);
  output.textContent = `Finished generating ${quota.value} primes!`;
});

document.querySelector("#reload").addEventListener("click", () => {
  document.location.reload();
});

/*
Try clicking "Generate primes". 
Depending on how fast your computer is, 
it will probably take a few seconds before the 
program displays the "Finished!" message.

*/


//Event handlers
const log = document.querySelector(".event-log");

document.querySelector("#xhr").addEventListener("click", () => {
  log.textContent = "";

  const xhr = new XMLHttpRequest();

  xhr.addEventListener("loadend", () => {
    log.textContent = `${log.textContent}Finished with status: ${xhr.status}`;
  });

  xhr.open(
    "GET",
    "https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json",
  );
  xhr.send();
  log.textContent = `${log.textContent}Started XHR request\n`;
});

document.querySelector("#reload").addEventListener("click", () => {
  log.textContent = "";
  document.location.reload();
});

/* 
This is an event handler just the same as handlers 
for user actions such as the user clicking a button. 
This time, however, the event is a change in the 
state of an object.

*/


//Call backs part 1

function doStep1(init) {
  return init + 1;
}

function doStep2(init) {
  return init + 2;
}

function doStep3(init) {
  return init + 3;
}

function doOperation() {
  let result = 0;
  result = doStep1(result);
  result = doStep2(result);
  result = doStep3(result);
  console.log(`result: ${result}`);
}

doOperation();

//Call backs part 2

function doStep1(init, callback) {
  const result = init + 1;
  callback(result);
}

function doStep2(init, callback) {
  const result = init + 2;
  callback(result);
}

function doStep3(init, callback) {
  const result = init + 3;
  callback(result);
}

function doOperation() {
  doStep1(0, (result1) => {
    doStep2(result1, (result2) => {
      doStep3(result2, (result3) => {
        console.log(`result: ${result3}`);
      });
    });
  });
}

doOperation();